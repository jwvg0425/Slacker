논세이프 모드
====
__현재__ : 글로벌락이 동작하여, 무조건 1스레드만 스크립트 관련 작업 진행.<br>
__논세이프모드__ :  하나의 큐에 작업을 쌓아놓고, 스레드풀에서 하나씩 빼서 처리하는 방식, 동시에 여러 메세지를 처리할 수 있다.<br>

목적
----
스크립트는 좀 쉽게 쓰자,<br>
동시에 여러스레드 돌려서 효율을 올릴라는게 아니라, 네트워크 작업이나 다른걸 모두 동기 API로 제공하고 동기 API만 쭉쭉 써도 알아서 잘 돌게 하기 위해서.

StopTheWorld
----
관리되는 언어의 `GC`처럼 전체를 멈춰 세울 수 있는 기능을 제공한다. <br>
해당 블럭 안에 있는 코드가 모두 실행되기 전까지 스레드풀의 다른 작업들은 모두 멈춘다.
```c#
// 파일 변경 이벤트도, `작업`으로 분류하여 똑같이 큐에 쌓는다.
void OnFileChanged() {
  // 컴파일은 굳이 StopTheWorld 영역에서 실행될 필요가 없음
  var assembly = CompileScript(); 
  
  using(var _lock = Bot.StopTheWorld()) {
    // 스크립트 엔진의 어셈블리 교체
    ChangeScriptAssembly(assembly);
    // 새로운 어셈블리 부트스트랩
    OnBootstrap();
  }
  
  // StopTheWorld 해제됨
  // 여기부터 Dequeue되는 작업들은 변경된 어셈블리로 동작한다.
}
```

BreakingChanges
----
`Subscriber`들이 전역변수에 접근할 때 수동으로 락을 걸어야 함.<br>
`Bot.RunOnBotContext` API 삭제

다른 대안
----
현재 버전으로도 샤딩확장 옵션을 이용하여 위와 같은 효과를 낼 수 있다. 다만 아래와 같은 단점이
* 샤딩은 로드밸런싱이 반-확률에 기반하고있어서 노는애는 놀고 바쁜애만 계속 바쁠 수는 있는데 (이건 거의 이론상의 케이스여서 별로 신경 안씀)
* 인스턴스를 여러개 띄우는 구조라 확실히 비효율적이다.
* 프로세스가 분리가되버려서 전역변수 공유가 안된다.
* Persistent API는 아예 못쓴다. (멀티프로세스 unsafe한 API)

위 단점을 해결하기 위한 옵션
* SharedMem 모듈 추가 (Persistent도 대체)
* 유저id 기반 샤드키 옵션 추가 (전역변수가 인스턴스간 공유가 안되도, 같은유저는 항상 같은인스턴스로 가니까 대부분의 경우 사용 가능)
